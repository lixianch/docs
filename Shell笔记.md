#### 一、基础变量

**1.定义变量**  
变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则： 
1. 首个字符必须为字母（a-z，A-Z）。  
2. 中间不能有空格，可以使用下划线（_）。  
3. 不能使用标点符号。  
4. 不能使用bash里的关键字（可用help命令查看保留关键字）。  
5. 变量是严格区分大小写的。 

**2.使用变量**  
使用一个定义过的变量，只要在变量名前面加美元符号（$）  
变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界  
**3.重新定义变量**  
已定义的变量，可以被重新定义  
**4.只读变量**  
使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。
```
readonly  变量名称 把变量设为只读变量  
-f  函数名称 设定该函数式不可修改  
-a  数组变量 -a后的数组变量名称是只读数组
declare -r 变量名称 把变量设为只读变量
-a  变量名称设定变量是一个数组
-p  变量名称显示变量的属性       
-i  变量名称变量是一个整数
-x  变量名称变成环境变量
```
**5.删除变量**  
变量被删除后不能再次使用；unset 命令不能删除只读变量。  
```
变量名称=  等号右边为空，代表将变量值设为null  
unset    变量名称    不加任何选项，会先尝试取消变量，若失败，再试着取消与该变量同名的函数  
unset -v 变量名称    -v 表示要取消的是变量  
unset -f 函数名称    -f 表示要取消的是函数  
```
**6.alias 别名=指令**  
1、等号两边不能有空白  
2、等号右边有空白字符，需要用引号''，文件位置在家目录下.bashrc  
**7.变量类型**  
运行shell时，会同时存在三种变量：  
1) 局部变量    
局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。  
2) 环境变量    
所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
"declare -x 变量名称" 和 “export 变量名称” 都可以把变量变成环境变量。  
3) shell变量    
shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行  
特殊变量    
\ 转义，把具有特殊含义的字符转为无代表意义的字符串。    
变量含义    
```
$0 当前脚本的文件名 
$n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 
$# 传递给脚本或函数的参数个数。 
$* 传递给脚本或函数的所有参数(一个整体的字符串)。 
$@ 传递给脚本或函数的所有参数(一个个字符串)。被双引号(" ")包含时，与 $* 稍有不同，下面将会讲到。 
$? 上个命令的退出状态，或函数的返回值。 
$$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 
$! Shell最后运行的后台Process的PID
```
$\* 和 $@ 的区别  
从上边的例子中，看起来$\*和$@输出结果是一样的，其实不然，$\*输出的是"one two three four"一个整体的字符串，而$@输出的是one、two、three、four四个字符串。  
技巧  
在写脚本的时候，为了怕打错变量名称，造成排错上的困难，我们可以规定：变量一律要先经过设定的程序才能使用。  
```
shopt -s -o nounset  
-s 是打开选项的意思；  
-o 是指可用set -o设定的选项
nounset表示变量一定要先设定过，才能使用  
```
#### 二、数组  
数组是一种数据结构，由相关的数据项组成。每个数据项称为数组的元素，且可使用索引的方式取得各元素的值。  
bash的数组，其元素的个数没有限制，数组的索引由0开始，但不一定要连续(可以跳号)。  
显示或取得某一元素的值${数组[索引值]}，例 数组A的第3个元素为${A[2]}。索引是可以做算术运算的。  
使用数组的索引时，第一个元素由0开始，第n个元素的索引值为n-1  
```
echo ${数组[@]} 取出所有元素，得到的是以空格隔开的字符  
echo ${数组[*]} 取出所有元素，得到的是一串字符串  
echo${#数组[@]}或echo ${#数组[*]}取得数组元素的个数  
unset 数组 取消数组  
unset 数组[2]   取消数组中的第3个元素  
```
#### 三、高级变量  
高级变量包含三个部分  
**1、变量扩展**  
**2、命令替换**  
**3、算术扩展**  
在Bash Shell中，$算符会触发到上述三种扩展，基本形式如下：  

    基本型|扩展种类|例子   
    :---:|:---:|:---:
    ${变量名称}|变量扩展|${filename}
    $(命令)|命令替换|$(ls /)
    $((算术式))|算术扩展|$((5+3))


变量存在表示变量有值(包含空) 
 
**变量扩展：测试存在性及空值**  
测试变量“存在与否”的基本用法  
**${待测变量-默认值}**  
如果待测变量有定义（包括为空），则传回待测变量默认值，如果无定义，则传回-后的默认值。
```  
a=yang  a=  
b=${a-'hello'}  
echo $b  
```
因为变量a有存在，所以$b值为yang，如果a存在，但为空，那么$b值为空。如果a不存在，$b为hello  
变量分为两种状态，1 存在(包括为空) 2 不存在  
**${待测变量:-默认值}**  
如果待测变量存在，则传回待测变量默认值，如果不存在或为空，则传回:-后的默认值。  
```
a=yang   a=  
b=${a:-'hello'}  
echo $b  
```
因为变量a存在，所以$b值为yang，如果a为空或不存在，$b的值就为:-后的hello  
***总结：  
如果变量扩展条件式只有-  则只做变量存在性的判断。  
使用:- 则除了做变量是否存在，还会判断变量是否为空  
一句话：多了个“:”，就要同时测试存在性及空值两种情况。***  

[ -n ${A:-} ] && set -v  
[]是测试条件的语法，-n测试其后接的变量为空，若非空，传回真值(长度不为0为真，-z长度为0为真)。  
**${待测变量:=默认值}**  
如果待测变量不存在或为空，就把待测变量值设为:=后的默认值。若存在，则设为待测变量值。  
```
a=yang                     
b=${a:='hello'}  
echo $b 
``` 
因为变量a存在，所以$b值为yang，如果a为空或不存在，$b的值就为:=后的hello  
***b=${a:-'hello'}和b=${a:='hello'}看上去好像是一样的，但是:-是当变量a为空或者不存在的时候，其后的值hello为变量b的值,a依旧是空或不存在。:=是当变量a为空或不存在的时候，其后的值hello为变量b的值，并且默认为变量a的值(相当于给a赋了一个值)。***  

**${待测变量:？提示信息}**  
若变量不存在或为空值，则显示变量名称和:?后的提示信息，并立即停止执行脚本。  
目的：确保变量值一定存在，否则不执行脚本。
```  
#!/bin/bash  
fn=${1:?'错误，请提供要删除目录的名称'}                    对传入的第一个参数做检查，若未空，显示提示信息，并停止脚本。  
echo '你要删除的目录指令是:'  
echo "rm -rf ~/$fn"  
```
测试变量的"存在性"  
**{待测变量:+真值}**  
若变量存在，且不为空，则传回“真值”，否则传回空值。  
```
a=123  
b=${a:+'true'}  
echo $b  
```
因为a存在，且值非空，所以$b为true，如果a不存在或a为空，那么$b值为空。  
***小结：***  

    符号|名称|含义
    ---|---|---
    :   |     空     |     测空值
    -   |     负向    |    测不存在
    =   |     设值    |    给空值变量设一个默认值
    ?   |     有问题  |    检查条件是否完备再来执行吧
    +   |     正向    |    测试存在
**2、变量扩展：取字符串切片、字符串长度**  
    字符串的第一个字符，编号为0，右邻的字符编号，依次增加1.接下来介绍如如何字符串的某一部分以及如何取得字符串长度  
取字符串切片
${变量:位置起点}            位置起点等同于下边的编号。
```
a="hello,world"
b=${a:3}
echo $b
```
由第4个字符开始，到结束。$b值为lo，world
 ${变量:位置起点:长度}
```
a="hello,world"
b=${a:3:5}
echo $b
```
由第4个字符开始，共5个字符。$b的值为lo，wo
取部分位置参数
${@:n} n为正整数，为位置起点到最后
```
!/bin/bash
echo $0
echo ${@:2}  除了命令本身，从第2个字符(命令本身为0，编号为3)到最后
./script.sh 12 23 34 45 返回值为23 34 45
${@:n:m} n、m为正整数,n是起始字符，m是长度
!/bin/bash
echo $0
echo ${@:2:4}      长度为4 
./script.sh 12 23 34 45 56 67 78 返回值为23 34 45 56
```
计算字符串长度
${#变量名称}    传回变量值的字符串长度
```
[root@Shell ~]# cat 1.sh 
#!/bin/bash
#
A='/etc/passwd'
echo ${#A}
[root@Shell ~]# bash 1.sh 
11
[root@Shell ~]#
```
${#数组[@]}        取得数组元素个数  
${#数组[\*]}        取得数组元素个数  
**3、变量扩展：对比样式**  
这里说的"对比样式"，目的是想截取变量值(字符串)的某一部分。做法是将符合样式的部分字符串删除或取代。  
由字符串前面对比，删除相符者  
由前边（最左开始），对比变量值，删除最短相符合的字符串。  
${变量#样式}  
```
a="/usr/sbin/ntpdate"
b=${a#/*/}
echo $b
```
/*/代表，凡一对/之间有字符串者，对比符合，那$b值为sbin/ntpdate
由前边（最左开始），对比变量值，删除最长相符合的字符串。
${变量##样式}
```
a="/usr/sbin/ntpdate"
b=${a##/*/}
echo $b
```
/*/代表，凡一对/之间有字符串者，对比符合，那$b值为ntpdate
由字符串后面对比，删除相符者
由后边（最右开始），对比变量值，删除最短相符合的字符串。
${变量%样式}
```
a="/usr/sbin/ntpdate"
b=${a%/*}
echo $b
```
/*代表，凡一对/之间有字符串者，对比符合，那$b值为/usr/sbin
由后边（最右开始），对比变量值，删除最长相符合的字符串。
${变量%%样式}
```
a="/usr/sbin/ntpdate"                                 a="www.baidu.com"
b=${a%%/*}          b=${a%%.*}
echo $b             echo $b  此时 $b为www
```
/*代表，凡一对/之间有字符串者，对比符合，那$b值为空

***小结：***

语法  |              用途
---|---
${变量#样式}     |   由前边对比、删最短的
${变量##样式}    |   由前边对比、删最长的
${变量%样式}     |   由后边对比、删最短的
${变量%%样式}    |   由后边对比、删最长的
取代或删除部分字符串
只替换第一个对比符号的字符串（如果删除，替换字符处为空）
${变量/样式/替换字符串}
```
a="root:x:0:0:root:/root:/bin/bash"
b=${a/:/,}
echo $b
```
$b值为root,x:0:0:root:/root:/bin/bash
替换所有对比符合的字符串（如果删除，替换字符处为空）
${变量//样式/替换字符串}   
```             
a="root:x:0:0:root:/root:/bin/bash"
b=${a//:/,}
echo $b
```
$b值为root,x,0,0,root,/root,/bin/bash   
b=${a/#s /} 删除以s开头的行以空格结尾  
b=${a/%s /} 删除以s结尾的行  
**4、变量扩展：取变量名称列表、数组索引列表**  
取变量名称列表  
${!开头字符串@} 或${!开头字符串*} 
```   
echo ${!x@} 或${!x*}         以x开头的变量名称。
a1=11
a2=dfds
b=sfs
echo ${!a@}  值为a1、a2
```
取数组索引列表
${!数组变量[@]} 或${!数组变量[*]}
```
[root@Shell ~]# cat 1.sh 
#!/bin/bash
#
a=(one two three four five)
for i in "${!a[@]}"
do
   echo "第$i个字符串为${a[$i]}"
done
[root@Shell ~]# bash 1.sh 
第0个字符串为one
第1个字符串为two
第2个字符串为three
第3个字符串为four
第4个字符串为five
[root@Shell ~]# 
```
**5、命令替换**  
这里的命令替换指的是把命令执行后的标准输出放入变量中，有两种写法：  
新式写法：变量名称=$(命令)  
旧式写法：变量名称=\`命令\`
旧式写法的引号为反引号，一般位于Tab键上方。  
```
[root@Shell ~]# ls /home/
lost+found  nagios  xguest
[root@Shell ~]# cat 1.sh 
#!/bin/bash
#
a=$(ls /home)
for f in $a
do
 echo $f
done
[root@Shell ~]# bash 1.sh 
lost+found
nagios
xguest
[root@Shell ~]# 
```
IFS是指定分隔符，默认是空白或Tab  
**6、算术扩展**  
如果a=8+4 b=$a echo $b 输出结果肯定为8+4 ，因为bash shell 把任何存储在变量中的值，皆视为以字符组成的字符串。  
算术扩展的语法:$((算术式))  
```
a=3+4
b=$a
echo $b 
输出则为7
```
**四、单引号、双引号、反引号的区别**  
单引号字符串的限制：  
1、单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；  
2、单引号字串中不能出现单引号（对单引号使用转义符后也不行）。  
双引号的优点：   
1、双引号里可以有变量  
2、双引号里可以出现转义字符  
反引号  
反引号括起来的东西是一个执行的命令  
date是一个可以查看日期的命令  
PWD是内部变量，echo $PWD显示当前路径  
我们看一下使用不同的符号会有什么效果  
1、美元符号$在单、双引号的表现，单引号中的$将保留它的字面意思，双引号中的$将发生变量引用  
```
[root@Shell ~]# echo '$PWD'
$PWD
[root@Shell ~]# echo "$PWD"
/root
```
2、反斜杠\在单、双引号中的表现，单引号中\将保留它的字面意思，双引号中的\转义后边的字符(失去特殊意义)  
```
[root@Shell ~]# echo '\$PWD'
\$PWD
[root@Shell ~]# echo "\$PWD"
$PWD
```
3、反引号与其它两种符号不同，反引号包围起来的字符串将被运行，取其结果。  
```
[root@Shell ~]# echo 'date'
date
[root@Shell ~]# echo "date"
date
[root@Shell ~]# echo `date`
Fri May 1 12:39:21 CST 2015
```
注:反引号中的date被当成命令执行，包含的正是命令从输出信息。  
***总结：  
当需要一个字符串的时候，使用单引号；
当内部包含变量的时候，使用双引号；
当铺捉命令输出的时候，用反引号；***


**算术运算**
在Bash的算术运算中有以下几种方法：

名称        |        语法           |         范例
---|---|---
算术扩展     |       $((算术式))     |         r=$((1+2*3))
使用外部程序expr  |  expr 算术式      |        r=\`expr 1 + 2 \* 3\`
使用$[]          |   $[算术式]       |         r=$[1+2]
使用内置命令      |  declare -i 变量=算术式 |   declare -i r=1+2*3
使用内置命令let   |  let 算术式       |         let r=1+2

i++运算后加1，i--运算后减1  
++i运算前加1，--i运算前减1  
**一、算术扩展**  
算术扩展的语法是：$((表达式))，如果表达式中有变量，该变量之前最好不要加$这个符号，以免变量不存在造成语法错误，例：  
```
unset i
echo $((2+$i))
```
由于变量i不存在，所以会变成 echo $((2+)),这样语法就错误了。
但如果写成echo $((2+i)),((2+i))是一个合法的算术式，就算变量不存在，仍可正确计算。
```
a=5
a=$((++1)) a的值加1后，在赋值给a
a=$((--1)) a的值减1后，在赋值给a
a=$((3+a--))运算后减1
```
**二、使用外部程序expr做算术运算**  
外部程序expr本来的作用，是在“标准输出”显示表达式的值。这个是外部程序，和Shell没有关系，所以移植性非常好，
如果注重跨平台，那么可以在脚本本使用expr代替其他算术表达式。
expr 3 + 4  
它会在屏幕上显示7，注意"+"两边有空格。
在使用expr时，要特别"表达式"中是否包含shell的特殊字符，如\*、|、\<、\*>、!、&、(、)，要使用"\"来转义。  
1、r=\`expr 参数1 \|参数2\`  
|代表"或"之意.如果”参数1“存在、非空、不是0，则传回”参数1“的值，否则传回"参数2"的值。   
r=\`expr 3 \| 0\` r的值为3  
r=\`expr 0 \| 2\` r的值为2  
2、r=\`expr 参数1 \&参数2\`  
如果"参数1"和"参数2"都存在、非空、不是0，则传回"参数1"的值，否则传回0.  
r=\`expr 3 \& 0\` r的值为0  
3、比较  

算术       |     		是否成立 |   r的值
---|---|---
r=\`expr 1 \< 2\`   |   是   |     1 
r=\`expr 3 \<= 2\`  |   否   |     0 
r=\`expr 2 \= 2\`   |   是   |     1 
r=\`expr 3 \!= 2\`  |   是   |     1 
r=\`expr 3 \>= 2\`  |   是   |     1 
r=\`expr 3 \> 2\`   |   是   |     1 

4、加  
r=\`expr 4 + 5\` r的值为9  
5、减  
r=\`expr 3 - 5\` r的值为-2  
6、乘  
r=\`expr 3 \\* 5\` r的值为15  
7、除  
r=\`expr 32 / 5\` r的值为6（余数无条件舍去）  
8、乘方  
expr没有乘方的功能  
9、求余数   
r=\`expr 32 % 5\` r的值为2  
10、计算字符串长度  
r=\`expr length "hello"\`  r的值为5  
**三、用$[]做算术运算**  
使用$[]做算术运算和$(())类似  
加：r=$[4+5]    r的值为9  
减：r=$[4-5]    r的值为-1  
乘：r=$[4\*5]    r的值为20  
除：r=$[5/2]    r的值为2  
余数：r=$[5%2]  r的值为1  
乘方：r=$[2\*\*3] r的值为8    
**四、使用declare、let做算术运算**  
declare为bash shell的内置命令。  
```
declare -i I
I=5+4 
echo $I 
```
因为I事先被定义为整数(算术运算)，所以$I的值为9，而不再是字符串5+4
当被定义为整数后，便可以进行加、减、乘、除..等操作  
**五、用let做算术运算**  
let为bash shell的内置命令。  
```
let I=8+4*5
echo $I 
此时输出的值为28
```
let表明后边的直接说一个算术式。  
也可使用空格符让表达式可读性高一点，但这时必须使用引号包括表达式才行。  
```
let "i = i + 5"
```

## 条件判断式 ##

**一、条件测试的写法**  
条件测试的写法有6种。（传回结果0为真值，非0为假值）  
1、执行某一个命令的结果。  
```
   if grep -q "root" /etc/passwd;then (-q 静默，只为判断$?)
      echo "root is exist"
```
其结束状态为最后一个命令执行的结果  
2、传回某一命令结果的相反值。  
   ! 命令（中间要用空格隔开）  
```
   if ! grep -q "root" /etc/passwd;then (-q 静默，只为判断$?)
      echo "root is not exist"
```
如果命令传回结果为0，则加上!之后传回值为1；反之如果命令传回值为非0，则加上!之后传回值为0  
3、使用复合命令((算式))  
   运算结果不为0为真，为0为假  
   ((8*3)) 24 真  
   ((5-5)) 0  假  
   ((20<30))  真     
   ((20>30))  假  
   ((20&&30)) 真  
   ((20&&0))  假     
4、使用Bash关键字'[[  ]]'组成的句子:[[ 判断式 ]]  
   [[ 后和 ]]前至少有一个空格  
``` 
   if [[ str > xyz ]];then
      echo "字符串str比较大"
```
5、使用内置命令：test判断式  
```
   if test "str" \> "xyz";then                     （>为特殊字符，用\转义）
      echo "字符串str比较大"
```
6、使用内置命令：[ ]判断式  
   [] 与test用法相同  
```
   if [ "str" \> "xyz" ];then                     （>为特殊字符，用\转义）
      echo "字符串str比较大" 
```
逻辑操作符：  

操作符 | 在(())或[[]]中 | 在[]中
---|---|---
逻辑与|&&|-a
逻辑或|\|\||-o
取反 |!|!

例子：   
1、使用-a、-o进行逻辑组合  
   [ -r filename -a -x filename] 如果filename可读且可执行，则为真。-a，且。  
   [ -r filename -o -x filename] 如果filename可读或可执行，则为真。-o，或。  
2、命令1&&命令2  
   命令1真才执行命令2，都真传回值0，否则1  
```
  if grep -q "root" /etc/passwd && ((8<10));then
```
3、命令1||命令2  
   命令1假才执行命令2，如果一个命令或都为真传回值0，否则1  
```
   ((2<3))||((4<5));then  
```
4、$$和||合用  
   如果是 “[ 判断式 ] &&指令1||指令2”形式，视为 if-then-else   
   [ "2" \> "1" ]&& echo "right"||echo "error"等同于等同于以下脚本：  
```
   if [ "2" \> "1" ];then
     echo "right"
  else
     echo "error"
   fi
```
总结：  
[[ ]]、test、[]用法意思相近，但[[ ]]更自由（不必担心特殊符号，不必转义），(())也不受特殊符号影响。    
在[[判断式]]中，如果使用==或!=且右方的字符串没有使用单引号、双引号，则视为对比该字符串形成的“样式”，如果相符，传回0，否则1。    
相似点：    

[]和test，两者是一样的，在命令行里test expr和[ expr ]的效果相同。test的三个基本作用是判断文件、判断字符串、判断整数。支持使用与或非将表达式连接起来。要注意的有：  

1.test中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq, -gt这种形式。无论是字符串比较还是整数比较都千万不要使用大于号小于号。当然，如果你实在想用也是可以的，对于字符串比较可以使用尖括号的转义形式， 如果比较"ab"和"bc"：[ ab \< bc ]，结果为真，也就是返回状态为0.  

然后是[[ ]]，这是内置在shell中的一个命令，它就比刚才说的test强大的多了。支持字符串的模式匹配（使用=~操作符时甚至支持shell的正则表达式）。简直强大的令人发指！逻辑组合可以不使用test的-a,-o而使用&&,||这样更亲切的形式(针对c、Java程序员)。当然，也不用想的太复杂，基本只要记住  
1.字符串比较时可以把右边的作为一个模式（这是右边的字符串不加双引号的情况下。如果右边的字符串加了双引号，则认为是一个文本字符串。），而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。
另外要注意的是，**使用[]和[[]]的时候不要吝啬空格，每一项两边都要有空格**，[[ 1 == 2 ]]的结果为“假”，但[[ 1==2 ]]的结果为“真”！后一种显然是错的  

3.最后就是let和(())，两者也是一样的(或者说基本上是一样的，双括号比let稍弱一些)。主要进行算术运算(上面的两个都不行)，也比较适合进 行整数比较，可以直接使用熟悉的<,>等比较运算符。可以直接使用变量名如var而不需要$var这样的形式。支持分号隔开的多个表达式  

不同点：  

1. 首先，尽管很相似，但是从概念上讲，二者是不同层次的东西。  
"[["，是关键字，许多shell(如ash bsh)并不支持这种方式。ksh, bash(据说从2.02起引入对[[的支持)等支持。
"["是一条命令， 与test等价，大多数shell都支持。在现代的大多数sh实现中，"["与"test"是内部(builtin)命令，换句话说执行"test"/"["时不会调用/some/path/to/test这样的外部命令(如果有这样的命令的话)。  

2.[[]]结构比Bash版本的[]更通用。在[[和]]之间的所有的字符都不会被文件扩展或是标记分割，但是会有参数引用和命令替换。  
用[[ ... ]]测试结构比用[ ... ]更能防止脚本里的许多逻辑错误。比如说，&&,||,<和>操作符能在一个[[]]测试里通过，但在[]结构会发生错误。  
3.(( ))结构扩展并计算一个算术表达式的值。如果表达式值为0，会返回1或假作为退出状态码。一个非零值的表达式返回一个0或真作为退出状态码。这个结构和先前test命令及[]结构的讨论刚好相反。  
4.[ ... ]为shell命令，所以在其中的表达式应是它的命令行参数，所以串比较操作符">" 与"<"必须转义，否则就变成IO改向操作符了(请参看上面2中的例子)。在[[中"<"与">"不需转义；  
由于"[["是关键字，不会做命令行扩展，因而相对的语法就稍严格些。例如
在[ ... ]中可以用引号括起操作符，因为在做命令行扩展时会去掉这些引号，而在[[ ... ]]则不允许这样做。  
5.[[ ... ]]进行算术扩展，而[ ... ]不做  
6.[[ ... && ... && ...  ]] 和 [ ... -a ... -a ...] 不一样，**[[ ]] 是逻辑短路操作，而 [ ] 不会进行逻辑短路**  
1）在ksh中的test  
数字的运算可使用let、(( )) ，其中运算时不需要变量$符号，运算符为 +、-、、\*、/、%，不建议使用expr  
数字的比较使用 (( )) ，其运算符 >、>=、<、<=、==、!=  
可以使用算术扩展，如：(( 99+1 <= 101 ))  
字符表达式的比较使用 [[ ]] ，其运算符 =、!=、-n、-z  
文件表达式的测试使用 [[ ]] ，其运算符 -r、-l、-w、-x、-f、-d、-s、-nt、-ot  
逻辑表达式的测试使用 [[ ]] ，其运算符 !、&&、||  
数字比较、字符比较、逻辑测试可以组合，如$ [[ "a" != "b" && 4 -gt 3 ]]  
支持bash中的通配符扩展，如：[[ hest = h??t ]] 、[ hest = h*t ]]  
使用 (( )) 时，不需要空格分隔各值和运算符，使用 [[ ]] 时需要用空格分隔各值和运算符。  
2）bash与ksh中的 [[ ]] 不同  
在redhat9的bash中也可以使用 [[ ]] 符号。但是建议严格按照上面的原则使用。  
在bash中，数字的比较最好使用 (( ))，虽说可以使用 [[ ]]，但若在其内使用运算符 >、>=、<、<=、==、!= 时，其结果经常是错误的，不过若在 [[ ]] 中使用 [ ] 中的运算符“-eq、-ne、-le、-lt、-gt、-ge”等，还尚未发现有错。因此诸如$ [[ " a" != “b” && 4 > 3 ]] 这类组合（见上）也不可以在bash中使用，其出错率很高。  
例：[[ "a" != "b" && 10 > 2 ]] 判断结果就不正常。  
诸如 [ 2 \< 10 ]、[[ 2 < 10 ]] 都是不要使用。使用算术扩展最好用 (( 99+1 == 100 )) ，而不要使用[[ 99+1 -eq 100 ]] 。  


字符串比较、判断是否为数字例子：  
 
二元比较操作符,比较变量或者比较数字.注意数字与字符串的区别.  

整数比较  

-eq       等于,如:if [ "$a" -eq "$b" ]  
-ne       不等于,如:if [ "$a" -ne "$b" ]  
-gt       大于,如:if [ "$a" -gt "$b" ]  
-ge       大于等于,如:if [ "$a" -ge "$b" ]  
-lt       小于,如:if [ "$a" -lt "$b" ]  
-le       小于等于,如:if [ "$a" -le "$b" ]  
<       小于(需要双括号),如:(("$a" < "$b"))  
<=       小于等于(需要双括号),如:(("$a" <= "$b"))  
\>       大于(需要双括号),如:(("$a" > "$b"))  
\>=       大于等于(需要双括号),如:(("$a" >= "$b"))  

字符串比较  
=       等于,如:if [ "$a" = "$b" ]  
==       等于,如:if [ "$a" == "$b" ],与=等价  
       注意:==的功能在[[]]和[]中的行为是不同的,如下:  
       1 [[ $a == z* ]]    # 如果$a以"z"开头(模式匹配)那么将为true  
       2 [[ $a == "z*" ]] # 如果$a等于z*(字符匹配),那么结果为true  
       3  
       4 [ $a == z* ]      # File globbing 和word   splitting将会发生
       5 [ "$a" == "z*" ] # 如果$a等于z*(字符匹配),那么结果为true  
       一点解释,关于File globbing是一种关于文件的速记法,比如"*.c"就是,再如~也是.  
       但是file globbing并不是严格的正则表达式,虽然绝大多数情况下结构比较像.  
!=       不等于,如:if [ "$a" != "$b" ]  
       这个操作符将在[[]]结构中使用模式匹配.  
<       小于,在ASCII字母顺序下.如:  
       if [[ "$a" < "$b" ]]  
       if [ "$a" \< "$b" ]  
       注意:在[]结构中"<"需要被转义.  
\>       大于,在ASCII字母顺序下.如:  
       if [[ "$a" > "$b" ]]  
       if [ "$a" \> "$b" ]  
       注意:在[]结构中">"需要被转义.  
       具体参考Example 26-11来查看这个操作符应用的例子.  
-z       字符串为"null".就是长度为0.  
-n       字符串不为"null"  
       注意:  
       使用-n在[]结构中测试必须要用""把变量引起来.使用一个未被""的字符串来使用! -z
       或者就是未用""引用的字符串本身,放到[]结构中。虽然一般情况下可
       以工作,但这是不安全的.习惯于使用""来测试字符串是一种好习惯.  

```
!/bin/bash
a="str"
if [[ $a == ??? ]];then    意思是：用$a的值，对比样式???（3个字符串） 
  echo "hello"
fi
上边如果把if行改为 
if [[ $a == "???" ]];then  意思是：用$a和字符串???是否相等
```

**二、运算操作符**  
判断式:影响程序流程的式子，判断式分为“单元”和“二元”  
如  -f filename ，测试文件是否存在。-f后跟一个操作数的文件称为“单元”。  
如 参数1 -gt 参数2，测试参数1值是否大于参数2，-gt左右各接一个要比较的参数，这种判断式称为“二元”。  
关于文件的判断式:  

操作符|描述
--- | ---
-a/e | 文件存在
-b  | 文件存在，且文件是区域设备文件
-c  | 文件存在，且文件是字符设备文件
-d  | 文件存在，且文件是目录
-p  | 文件存在，且该文件是管道文件（FIFO）
-f  | 文件存在，且该文件是一般文件
-g  | 文件存在，且该文件设立了 set group id属性 -u uid
-h/L | 文件存在，且该文件是符号链接文件
-r  | 文件存在，且该文件有可读取的属性 -w 可写 -x 可执行
-s  | 文件存在，且该文件大小大于0（文件存在，且文件有数据）
-t  | 文件描述符   如果文件描述符是开启的，且链接了某一个终端
-S  | 文件存在，且该文件是socket文件
-N  | 文件存在，且该文件从上次读取后，曾修改过。
文件1  -nt 文件2 |  如果文件1比文件2新；文件1存在，但文件2不存在。
文件1  -ot 文件2 |  如果文件1比文件2旧；文件1不存在，但文件2存在。
文件1  -ef 文件2 |  如果文件1和文件2 参考到相同的设备和inode编号。
字符串比较运算符(请注意引号的使用，这是防止空格扰乱代码的好方法):

操作符|描述|例子
--- | ---|---
-z | 长度为0（即空字符串）|[ -z "$myvar" ]
-n | 长度不为0（即非空字符串）,字符串字符串长度不为0 |[ -n "$myvar" ] 
string1 = string2|	如果 string1 与 string2 相同，则为真|	[ "$myvar" = "one two three" ]
string1 != string2|	如果 string1 与 string2 不同，则为真|	[ "$myvar" != "one two three" ]
 
***注意：  
1、如果<>出现在[]或test中的时候，要用\转义  
2、==和=代表相同（左右两边分别有个字符串）***  
关于算式的条件判断式：  

(())或[[]]中操作符|[]中操作符 | 含义
---|--- | ---
==|-eq |  相等
!=|-ne |  不相等
<|-lt |  小于
<=|-le |  小于或等于
>|-gt |  大于
>=|-ge |  大于或等于

关于Bash选项的条件判断式:
-o   set选项的名称 如果该选项为开启状态则为真。
```
#!/bin/bash
set -o
if [ -o history ];then
  echo 'Bash选项history开启'
else
  echo 'Bash选项history关闭'
fi
```  

## 流程控制--选择 ##

流程控制可根据不同的情况做不同的处理，而且可重复执行指定的程序区域，展现程序的生产力。在Bash Shell中，流程控制可以分为两大类：  
“选择”和“循环”；  
1、选择：if、case、select  
2、循环：for、while、until、select  
命令select既属选择也属于循环。  
**一、命令的结束状态**  
在Shell中每一个命令执行后，都会传回一个结束状态值，只分两种，如果成功，传回0，失败则传回非0.  
当命令执行后，用$?来查看状态返回值，当在Shell进行条件测试的时候$?=0为真,$?=非0为假。  
```
[root@Shell ~]# pwd
/root
[root@Shell ~]# echo $?
0
[root@Shell ~]# pwdddd
-bash: pwdddd: command not found
[root@Shell ~]# echo $?
127
```
当一个命令正常执行的时候，$?=0.当一个命令输入错误的时候，$?=非0
比如yum安装软件、复制文件、删除文件、判断文件是否存在等..如果正确执行，则$?=0，如果中间出错，$?=非0  
 
**二、if条件判断**  
if 条件测试;then  
命令区域  
fi  
如果"条件测试"为真，就执行"命令区域"的指令，否则继续fi下一行指令。  
```
[root@Shell ~]# cat test.sh 
#!/bin/bash
#
if grep -q ^root /etc/passwd;then
echo "The user root is exist"
fi
[root@Shell ~]# bash test.sh 
The user root is exist
```
使用grep在/etc/passwd搜索以root开头的关键词，如果为真，就继续执行下边的命令(grep -q表示只判断真假，不作输出)。  
最简单的if语法：if-then-else  
if 条件测试;then  
命令区域1  
else  
命令区域2  
fi  
如果"条件测试"为真，就执行"命令区域1"的指令，否则就执行"命令区域2"的指令。  
```
[root@Shell ~]# cat test.sh 
#!/bin/bash
#
if grep -q ^roothi /etc/passwd;then
echo "The user roothi is exist"
else
echo "The user roothi not exist"
fi
[root@Shell ~]# bash test.sh 
The user roothi not exist
判断用户roothi是否存在。
```
**if的完整语法**
```
if   条件测试1;then
 命令区域1
elif  条件测试2;then
 命令区域2
else  
 命令区域3
fi
```
如果条件测试1为真，则执行命令区域1，如果为假，则执行条件测试2；如果条件测试2为真，则执行命令区域2，如果条件测试2为假，则执行命令区域3（elif条件可以有多个）。
```
[root@Shell ~]# ./test.sh 5 2
5 is the bigger!
[root@Shell ~]# ./test.sh 5 10
10 is the bigger!
[root@Shell ~]# ./test.sh 5 5
5 = 5 
[root@Shell ~]# cat test.sh 
#!/bin/bash
#
declare -i a b   #声明a b都在正整数
a=$1
b=$2
if (( $a > $b ));then
echo $a is the bigger!
elif (( $a < $b ));then
echo $b is the bigger!
else
echo "$a = $b "
fi
```
多行打印菜单选择：  
```
#!/bin/bash

cat <<END
choose the menu:
[1.install apache]
[2.install nginx]
[3.install lvs]
END
        
read -p "请选择要安装的软件：" a
echo $a

if (( $a==1 ));then
        echo "will install apache"
elif (( $a==2 ));then
        echo "will install nginx"
elif (( $a==3 ));then
        echo "will install lvs"
else
        echo "pls input valid selection number[1,2,3]"
fi
```
 
**三、case条件判断**
if条件判断中提到的if条件判断，一旦要进行的条件测试的情况多了起来，if和elif的语法就会变得很冗长，case条件判断语法可补其不足。
------------------case的语法结构------------------
case 待测项 in
   样式串行1 )命令区域1;;
   样式串行2 )命令区域2;;
   样式串行3 )命令区域3;;
   .....
   *) 命令区域;;
esca
样式串行可以是字符串：如a、b、mary
              通配符：*任意长度(包括空字符)  ?一个字符
              字符集合：[a-d]mm,表示amm、bmm、cmm、dmm
              分隔符：|             
如果待测项与样式串行符合的话，case会执行该样式后的命令区域，命令区域可以是单一指令或多行指令，最后以;;结束。
样式串行可以用字符串和通配符组成，默认会区别大小写。
如果串行有好几个字符要对比，用|隔开，|有或的意思（只要符合其中之一就算成功）。
样式串行可以写为'(样式串行)'或'样式串行'
*)通常放在case最后的一个区域，用来谱捉不符合指定样式的其它情况。
例子：
!/bin/bash
name=$1                                      第一个输入的参数附给name 
case $name in
  a|b|c)                                      匹配的选项1，变量为a或b或c的时候
     echo "hello,abc group"                   输出结果1
    ;;                                        ;;可放到输出结果1后，也可另起一行
  huan)                                       匹配选项2 ，变量为huan的时候
     echo "i love you"                        输出结果2
    ;;
  s*)                                         匹配选项3，变量以s开头的字符串
    echo "you are first s"                    输出结果3
    ;;
  *)                                          匹配选项4 不符合上边任何条件的字符串
    echo "what is this？";;                输出结果4 "what is this？".......    
esca      结束
-----------------高级样式--------------------
样式    符合情况
?(样式串行) 符合0个或1个
*(样式串行) 符合0个以上
+(样式串行) 符合1个以上
@(样式串行) 符合其中1个
!(样式串行) 只要不是出现在括号里的样式就算符合      
j@（ac|xy|pq)k|join|joe echo 'hello';;
只要变量符合jack、jxyk、jpqk、join、joe其中之一就算符合
if [[ $cmd == @(a|b) ]];then 
只要是a或b就算是对比成功。
流程控制--循环
一、for循环
    for循环的运作方式，是将串行的元素一一取出，依序放入指定的变量中，然后重复执行包含的命令区域(在do和done之间)，直到所有的元素取
完为止。其中，串行是一些字符串的组合，彼此用$IFS所定义的分割字符(如空格)隔开，这些字段串称为字段。
for的语法
for  变量 in 串行    将串行的字段迭代放入变量中
do
    命令区域                        重复执行命令区域，知道串行中每个字段均处理过
done
!/bin/bash
for i in 1 2 3 4 
do
  echo $i
done
--------------------------------------------------------------
for 变量 in $@$@代表命令行所有的参数
do
 命令区域                        
done
 
#!/bin/bash
IFS=':'                         for循环经常用在分割字符串行，取出字段元素值
PL="root:x:0:0:root:/root:/bin/bash"
for i in $PL
do
 echo $i                         结果是依次输出每个字段
done
 
#!/bin/bash
DIR="/root"
for i in $(ls $DIR)
do
  echo "The files is $i"
done
 
#!/bin/bash
DIR="/etc"
cd $DIR
for i in $(ls $DIR)
do
[ -d $i ]&& du -s $i             如果是目录，输出其大小
done 
--------------------------------------------------------------
for ((初始条件;终止条件；异动项))
do 
   命令区域
done
!/bin/bash
declare -i i sum                 声明变量为整数
for ((i=1; i<=10; i=i+1))                     
do
  let sum+=i  sum每次增加i的值sum=sum+i
done
echo $sum                        值为1+2+..+10=55
--------------------------------------------------------------
无穷循环
for ((;1;))         
do
  命令
done
#!/bin/bash
for ((;1;))
do
  echo "hello"    屏幕无限输出 fuck，Ctrl+c结束
done
二、while循环
while的语法
while 条件测试   传回值为真，则进入命令，否则结束脚本
do
  命令区域       这些命令应该有改变条件测试的命令，这样才有机会在有限步骤后结束while循环（除非想执行无穷循环）。
done
!/bin/bash
declare -i i=1                           声明i和sum为整数型
declare -i sum=0
while ((i<=10))                          i只要小于等于10就循环
do
  let sum+=i                           sum+=i和sum=sum+i是一样的，sum累加上i
  let ++i                                i的值递增1，一单大于10 停止循环
done
echo $sum
--------------------------------------------------------------
#!/bin/bash
IFS=':'                                  分隔字符变量值为":"
while read f1 f2 f3 f4 f5 f6 f7          读取/etc/passwd各行账号数据，并放入f1~f7
do
 echo "账号:$f1,login shell是:$f7"        显示各个账户名字和它用的login shell
done < "/etc/passwd"                      通过转向，把/etc/passwd数据给read读取
--------------------------------------------------------------
#/bin/bash
IFS=':'
cat /etc/passwd | {                               cat /etc/passwd把指令用管道丢给{}组
while read f1 f2 f3 f4 f5 f6 f7
do
echo "账号是:$f1,login shell是$f7"
done
}
--------------------------------------------------------------
while 无穷循环
#!/bin/bash
while ((1))                 while[ 1 ] 或 while : 或 while true
do
 echo "hi"
done
三、until循环
while循环的条件是测真值，until循环则是测假值。
until语法
until 条件测试       如果条件测试结果为假（传回值不为0），就进入循环
do
  命令区域           这些命令应该有改变条件测试的命令，这样才有机会在有限步骤后结束unitl循环（除非想执行无穷循环）
done                 回到开始，执行until命令
!/bin/bash
declare -i i=1
declare -i sum=0
until ((i>10))             如果i不大于10就进入循环
do
  let sum+=i
  let ++i
done
echo $sum
---------------------------------------------------
until无穷循环
!/bin/bash
until ((0))            或until false
do
  echo "fuck"
done
四、Select命令
select命令可以建立简易的列表，语法和for一样
select语法
select 选项变量 in 串行
do
  命令区域
done
一般是结合函数使用，建立可视列表。
五、break和continue
如果想提前结束循环，可在循环中使用break，执行break后会跳出一层的循环，如果想跳出多层，可在break命令后加上层数n（n>=1）
#!/bin/bash
for ((i=1;i<=10;i++))
do
if [ $is -eq 6 ];then   如果i的值为6 就跳出循环
    break
fi
  echo $i
done
---------------------------------------------------
#!/bin/bash
for ((i=1;i<=10;i++))
do
  for ((j=1;j<=10;j++))
   do
   r=$((i+j))
   if [ $r -eq 19 ];then  当i和j的和为19的时候，跳出2层循环
    break 2
   fi
   echo $r
   done
done
continue命令会跳过本次循环，重新由下一个循环开始执行。
#!/bin/bash
for ((i=1;i<=10;++i))
do
 if [ $i -eq 6 ];then
continue
fi
echo $i
done
当i的值等于6的时候，就跳出本次循环（后边的命令不再执行,echo $i），然后重新由下一个循环开始，因此上边例子显示1~5、7~10,只有6没有显示，因为6的时候跳出去了，然后重新执行了。如果有多层循环，可在continue后面指定要由哪一层的循环重新开始执行。（如continue2表示从里面往外跳出2层循环，然后由那一层的循环重新开始）。
函数应用

函数是什么？
    函数是一些命令的集合，使用一个名称做代表，称为函数名称。函数名称的命名规则和变量相同。
    一旦函数定义好了，执行这个名称，就好象执行Bash的命令一样，称为调用函数。实际上，Bash调用函数时，会执行函数里的命令区域，执行
完毕，Bash会回到调用函数的下一行继续执行。
    函数的最大作用是可以让程序模块化。如果Script程序中，需要重复执行某一命令区域，那么就应当使用函数代表这个区域，一方面可使程序精简，一方面程序代码页比较容易维护。
一、函数的用法
1、函数的语法
语法1：
function 函数名称()
{
   命令区域
}
函数名称与()之间可以直接相连,也可用空格隔开。
语法2：
函数名称()
{
   命令区域
}
关键词function可省略
语法3：
function 函数名称
{
   命令区域
}
如果使用关键词function，函数名称后的()也可省略
例子：
#!/bin/bash
getline ()          #定义函数getline，用来定义文件行数
{
 local i=0          #i代表已计算的行数，先归0。               
    #local用来设定变量i是getline函数中专有的变量，不影响script其它地方也叫i的函数
 while read line                          
 do                 #使用while循环，自变量值$file指定文件读取每一行
  let ++i           #每读一行 变量i值+1
 done < $file       #使用转向输入，让read能由$file读取数据
 echo "$file文件共有$i行"   #显示总行
}
 
file=$1             #由命令行第一个参数，取得要计算行数的文件名。
getline             #调用getline函数
echo "getline 执行完毕"   #getline执行完后，回到这里继续执行下一指令。
#./script passwd
passwd文件共有36行
getline执行完毕
在调用函数之前一定要先定义该函数。
unset -f 函数  取消函数
2、函数的结束状态
执行函数时，函数中最后一个命令的传回值代表函数的结束状态。执行函数如果遇到return命令，就立即结束，回到调用函数的下一个命令，此时函数的传回值为0
#!/bin/bash
getline ()
{
local i=0
while read line
do 
  let ++i
  if (($i > 10));then        #判断是否超过10行
    echo "$file文件大于10行，不再继续"
    return                   #遇到return命令，立即回到echo$?所在行
     #默认传回值为0，也可指定不同的传回值，直接在return空格加数字即可
  fi
done < $file
echo "$file文件共有$i行"
}
 
file=$1
getline
echo $?
echo "getline 执行完毕"
 
可以根据$?(return 接的数字n )的值执行想要的命令，如上  if[ $? -eq 3 ];then
                                                 echo "行数过多，放弃读取"
                                                 else
                                                 echo 'getline执行完毕'
                                                 fi
二、函数与变量的作用范围。
1、函数的作用范围
函数仅在定义的shell环境中有效，Bash执行函数时，并不会另外再开启一个子shell。
如果要传递函数给shell环境使用，可以用内置命令export   -f函数名称，这样此函数就变成了环境变量的一部分（函数型），可供子shell的script调用。
2、变量的作用范围
如果没有特别的设定变量的属性，那么在Script中自定义的变量称为全局变量（对此脚本而言）。作用范围在整个Script文件中皆有效。
#!/bin/bash
getline ()
{
local i=0               #这就定义了变量i只在函数getline中有效，变量i和函数外其它叫i的变量完全不一样。
while read line
do 
....
三、位置参数
1、命令行的位置参数
$0   表示脚本名 $1 表示第一个参数 $2表示第2给参数 $(10)表示第10个参数
$*    代表所有的位置参数，看为一个字符串。1.sh a x y则$*为"a x y"
$@    代表所有以空白隔开的参数，各位置串行。    1.ah a x y则$@为"a"、"x"、"y"
$#    位置参数的个数，1.ah a x y则$#的值为3
#!/bin/bash
if [ $# -ne 2 ];then                必须键入2个参数，否则错误退出
  echo "使用方法:./$0 参数1 参数2"
  exit 1
fi 
2、移动位置参数
Bash的内置命令shift可以往前移动位置参数的值，语法如下：
shift n 
n为正整数，代表往前移动的次数。n可以省略不写代表移动一次。执行 shift n，$(n+1)的值会放入$1
以执行shift命令来说(不指定次数)，$2的值放入$1，$3的值放入$2，$4的值放入$3,，,如果一直执行shift(次数>=n)，会把所有的位置参数清空
shift 一次清除1个(从$1开始) ，shift 2 一次清除2个
#!/bin/bash
echo "\$@的初始值为$@"
while shift
do
[ -n "$1" ] && echo "shift 1次,\$@的变化:$@"
done
执行结果:
[root@centos tmp]# bash 1.sh  a b c d e 
$@的初始值为a b c d e
shift 1次,$@的变化:b c d e
shift 1次,$@的变化:c d e
shift 1次,$@的变化:d e
shift 1次,$@的变化:e
3、指定位置参数的值
指定位置参数的值称为重置(reset)，用Bash命令set
#!/bin/bash
declare -i i=0
set 10 20 30 40 50
 for p in $@
 do
 ((i++))
 echo " 第 $i 个位置参数 $$i = $p"     #$$目前bash shell的进程编号  
done
[root@centos tmp]# bash 2.sh 
 第 1 个位置参数 3547i = 10
 第 2 个位置参数 3547i = 20
 第 3 个位置参数 3547i = 30
 第 4 个位置参数 3547i = 40
 第 5 个位置参数 3547i = 50
一旦用set重置位置参数，其原有的值就会消失，改以新值取代。(无论输入几个参数，set设置几个就是几个)
如果要一次重置所有参数，使其值为空，可执行 set --
4、取用命令行的选项和参数
在设计脚本的时候，往往需要由命令行中取得用户提供的选项和参数，根据不同的选项，脚本有不同的处理方式和执行结果。选项的使用方式可以
是单一选项，也可以在选项后方加上准备作用的参数，而且，选项出现的次序并没有严格的要求。
如以下例子：
./script -u jacken -a -h
或改用以下形式
./script -a -u jacken -h
如果要想取得这些选项和参数，使用前述的位置参数也是可以的，不过拿到位置参数后，必须再做许多条件判断才行，因为选项可能以不同的次序
出现在命令行不同的位置，情况十分复杂。解决这样的问题，可改用Bash提供的内置命令getopts。
getopts语法如下：
getopts 选项行 选项变量
其中选项行，是由各选项的单一字符组成，如前述例子中用来3个选项，可组合成“u:ah”
如果某一个选项字符后方，接上":" 则表示该选项需要提供一个参数，如这里的u后面有":"
如果执行脚本的时候，选项u后方没有提供额外的参数，那么Bash就会显示“option requires an argument --u”的错误信息。
如果不想出现这种错误信息，可在选项行最前面加上":" 如 ":u:ah" 像这样子，u后边没有参数也不会报错了。
至于选项变量的作用是：
getopts由命令行取得选项，把它放入选项变量中，如果该选项需要额外的参数，参数值会放入OPTARG这个变量中。
例子：
[root@Shell ~]# ./opt.sh -a
提供了选项a
[root@Shell ~]# ./opt.sh -h
提供了选项h
[root@Shell ~]# ./opt.sh -a -h
提供了选项a
提供了选项h
[root@Shell ~]# ./opt.sh -u
./opt.sh: option requires an argument -- u
[root@Shell ~]# ./opt.sh -u hello
提供了选项-u和参数:hello
[root@Shell ~]# cat opt.sh 
#!/bin/bash
#
while getopts u:ah opt
do
  case $opt in
  u)
  echo "提供了选项-u和参数:$OPTARG";;
  a)
  echo "提供了选项a";;
  h)
  echo "提供了选项h";;
  *)
    ;;
  esac
done
[root@Shell ~]#
四、建立函数库
如果某些函数经常出现在设计的script中，可以考虑把这些函数抽出来，集中存成一个文件，但这个文件称为函数库。
在命名函数时，函数名称第一个字符使用_(下划线)，通常这就代表系统用的函数或变量名称。
在/tmp下建立函数库mylib1.sh
_getip()
{
  local tmp r ip                           #函数内部使用的变量设为私有
[ -z "$1" ] && return                      #如果位置参数$1为空，直接退出 
shuzu=()                                   #建立数组变量shuzu，作为传回ip字符串用，初始值设为空数组
tmp=$(ifconfig $1 | grep 'inet addr')           
r=${tmp/inet addr:/}
ip=${r/Bcast*/}
shuzu=($ip)                                #将找到的ip设为第一个数组元素，作为函数处理结果的传回值
}
调用函数数据库的语法，. /路径/函数数据库   .也用source来表示
#!/bin/bash
MYLIB_DIR="/tmp"                           #设置函数库默认路径
if [ ! -d "MYLIB_DIR" ];then
   MYLIB_DIR="."                           #如果默认路径不存在就设为当前目录
fi
. $MYLIB_DIR/mylib1.sh                     #调用函数库mylib1.sh
_getip eth0                                #执行_getip传入的参数是网络接口的名称eth0
ip=${shuzu[0]}                             #取出代表函数执行结果的数组变量shuzu的第一个元素，设值给变量ip
if [ -n "$ip" ];then                       #判断$ip是否为空，-z 为空 -n不为空
   echo "主机ip是:$ip"
else
   echo "找不到IP"
fi
 
转向的用法
一、文件代码
    “转向”的意思是说：原本应由标准输入（如键盘）读取数据的，改由其它文件读取；原本应把结果显示在标准输出（如屏幕）的，改输出到其它文件。在这个过程中会涉及到文件代码（file descriptor）的概念。
    所谓文件代码，是指操作系统赋予已开启文件一个编号（由0开始），作为追踪文件之用，如对这个文件进行读取或写入的操作，都使用文件代码来沟通。下边文件代码数字用fd来表示。
操作系统默认3个文件代码：0 标准输入、1 标准输出、2 标准错误 
这3个文件在建立Shell环境时已开启，往后如果开启新文件，则分配2以上的号码。
< 代表转向输入，如果< 左边省略文件代码，则默认为0，指的就是标准输入。
> 代表转向输出，如果> 左边省略文件代码，则默认为1，指的就是标准输出。
这些转向语法大部分不能单独使用，必须跟Bash的命令一起运用，如exec、ls、read等，是属于指令结构的一部分。
本篇中的fd、n、m代表文件代码
1
2
3
4
#echo ’hello,world!‘ > a.txt
#exec 7<>a.txt
#cat <&7
hello,world!


二、操作文件
这里要说明的"操作文件"，是指运用转向的概念，开启文件、复制文件代码和关闭文件。
1、开启文件
语法：fd<>文件
用途：开启文件，指定代码为fd。使用这种方式开启的文件，可供读写。
用例：exec 6<>test.txt
使用exec执行转向，开启文件test.txt，并指定其代码文件为6
2、关闭文件
开启文件后，如果该文件不再使用，最好关闭文件，交回调用文件代码所占用的系统资源。这是一个很好的习惯。
关闭转向输入文件
语法：fd<&-
用例：6<&-
关闭转向输出文件
语法：fd>&-
用例：exec 5>&-
3、复制文件代码，建立文件链接
操作系统已开启的文件代码（0、1、2），为了不影响原有文件代码的作用，最好先复制一份，等操作结束再还原回去，称“复制代码”。
两种方式：
a、复制转向输入的文件代码m，存文件代码n，使n连接至m     n<&m
b、复制转向输出的文件代码m，存成文件代码n，使n连接至m   n>&m
用例：
exec >&6   等同于exec 1>&6,将标准输出连接到文件代码6，因此，凡是出现在标准输出的内容，会转存至文件代码6
cat  <&6   等同于cat  0<&6,将文件代码6的内容，转向至标准输入，而由cat把内容显示出来。
exec 5<&0  复制标准输入(0),存成文件代码5，即建立文件代码0的连接，简单说就是做标准输入的备份。
exec 0<&5  5<&- 将存储在文件代码5的标准输入还原，并关闭文件代码5。


三、转向的用法
代码要紧邻符号，转向输入输出默认只能使用一次。
1、转向输入
语法：fd<文件 
用途：使用"文件"作为输入，指定它的文件代码为fd
用例：
wc -l < /etc/passwd  #<左方省略fd，默认fd为0，指的就是标准输入转向：
exec 6< /etc/passwd  #<左方文件代码不空；
wc -l <&6            #当一次输入回车的时候，会输出passwd行数，再按一次回车则为空             
2、转向输出
语法：fd>文件
用途：使用文件做输出，指定文件代码为fd
如果文件不存在，会建立，如果存在，会清空。可以关闭文件默认操作set -o noclobber或set -C
用例：
>test.txt(创建空文件)      #>左方的省略fd，fd默认为1
:>test.txt                 #效果同上
ls > dirs.txt              #存储命令执行的输出
exec 6> out.txt            #开启文件out.txt作为输出
echo 'hello world!' 1>&6   #将echo输出的内容存储在文件代码6
fd>|文件 同fd>文件 但fd>|不理会noclobber选项，会强制覆盖、清空。
>|不管noclobber选项是否启用，只要文件存在，该内容一定会被清空。
3、转向附加
语法：fd>>文件    
用途：使用方法同 fd>文件， 只是fd>>不会覆盖、不会清空，只是追加。
4、标准错误伴随标准输出做转向
语法：&>文件 或 >&文件 效果一样。
'>文件 2>&1'和 &>作用一样。
 
trap--陷阱触发
在script的执行过程中，有时候希望能实时处理系统传来的信号，如用户按了Ctrl-C。处理的方式分为两种：接受信号或忽略信号。
    接受信号通常会对信号安排执行特定的命令，忽略信号主要是避免意外的状况干扰script的运行。像这种能谱捉特定信息，并做出反应的机制称为trap(陷阱触发)。trap的应用和信号有关。
一、信号
1、进程编号PID
每个进程都是独一无二的代码，称为进程编号(Process IDentification)，简称PID。
ps auxw 或 ps -ef 列出内存所有进程
ps auxw | grep named | grep -v grep  找出包含named的行，排除包含grep 的行。
2、信号列表
kill -l 或 trap -l  列出系统定义的信号的列表
每个信号都有个特定的数字代码，如SIGINT的代码为2(信号名称已SIG开头，可以不写,SIGINT和INT是相同的)，信号名称不分大小写，在传递信号时，可用数字代码，也可使用信号名称。
"kill -1 进程号" 、"kill -HUP  进程号"、"kill -SIGHUP 进程号" 让此进程号的进程重启，3种写法效果一样。
3、传送信号的方法
"kill -信号 进程编号" 或 "kill -s 信号 进程编号" 或 "kill -n 信号 进程编号"
"-信号"可使用信号代码或信号名称。kill后可跟多个进程编号，kill会把指定的信号都传递给这些进程。如果省略"-信号"则默认传送SIGTERM(代码15，终止进程)信号给进程。
kill 2359(终止这个进程) kill -9 2359(强制终止进制) kill -KILL 2359(强制终止进程)
另外killall也可以传送信号给进程，只不过killall传送的对象是进程的名称。
killall -信号 进程名称
4、常用的信号
HUP             1重新启动进程
INT2按Ctrl-C键；中断进程
QUIT3按Ctrl-\键；以内核转储的方式离开进程
TERM15终止进程
KILL9强制删除进程
STOP19暂停进程
CONT18继续执行
TSTP20按Crtl-Z键；在终端中暂停进程
ABRT6放弃进程，并转存内核信息
SEGV11内存区段错误，并转存核心信息
最好的方式是使用信号名称，因为生产环境不同的unix-like系统进程代码可能不一样，具体要用kill -l查看
kill -TERM 进程编号 或 kill -15 进程编号
结束进程前有机会执行清理动作,没有强制性(未必会结束)。 kill -KILL 进程编号 或kill -9 进程编号，不执行清理动作，马上结束
kill -TSTP 进程编号或kill 20 进程编号，当执行Ctrl-Z时，对进程发出TSTP信号，通常把一个程序丢到后台去执行 ，按Ctrl-Z暂停，在执行bg，把它丢到后台执行，fg再调回前台。
需要注意的是如果把第一个进程放后台后，再把第二个进程放后台，此时bg只显示第二个进程，待第二个进程结束的时候，bg才会显示第一个进程
可以使用jobs 来查看当前放进后台暂停的进程，用fg n n为编号可以调出指定的后台暂停的进程。
 
二、trap的运用
1、trap的语法1  trap "触发指令" 信号串行
    只要系统产生特定信号，trap就会触发指令。trap 'echo 123' ABRT ; kill -ABRT $$ 屏幕会出现123 $$代表当前shell进程编号
2、trap的语法2  trap - 信号串行
    如果trap语法中没有触发指令，而是-或空白，则可恢复信号串行的原本的作用。trap '-' ABRT 恢复ABRT原本的作用。
3、trap的语法3  trap '' 信号串行
    忽略系统发出的信号串行  trap '' INT Ctrl-C讲失效，无法终止进程
4、trap的语法4  trap -p
    列出目前trap向shell注册的信号列表。
 
sed与awk

设计script时，有时候需要修改脚本，例如删除或置换某些关键词。像这种在script执行过程动态修改文件的做法，称为流编辑。具有流编辑能力的工具，称为流编辑器。sed是这方面的强者。另外script执行时可能要制作报表，呈现各字段信息，awk完美解决。
一、正则表达式
    正则表达式是组成“样式”的基本语法，而“样式”是运用sed和awk必备的能力。sed和awk相同的运行方式是：只要符合“样式”的数据行，就对它执行指定的“操作”。
什么是正则表达式？
正则表达式是一种描述的方法，一种小型的语言，可表示某种样式或若干种样式的组合，它的威力在于仅需几个简单的字符，便可代表许多字符串共同的样子。
1、. 代表任意字符
   .a. 代表中间为a，两边随意字符的3个字符。(若要对比.本身需要用\转义)
2、^ 代表在行首
   ^abc  abd应该出现在行首。"abc，hello"和"hello abc" 前者符合后者不符合
3、$ 代表在尾部
   $abc  abd应该出现在行尾。"abc，hello"和"hello abc" 后者符合前者不符合
4、[...] 字符集合
   [...] 代表字符 串行中的一个字符 [aBc]代表a或B或c。[A-Z]一个大写[^A-Z]除了大写之外的一个字符。
5、*出现0个以上
   a*c可以是abc、abbc、abbbc、aSJKSKBKc.....
6、\{...\}指定符合的个数
   \{3,5\}前边的字符有3~5个。[a-z]\{3,5\}代表以小写字母组成的字符串，长度为3~5个
7、\(..\)把对比符合的字符串暂时保存起来
   a\(..\)b要保存a、b之间的2个字符，若要提取保存的字符串，可用位置参数，\1代表第一个保存的字符串，\2代表第二个保持的字符串。
 
二、扩展正则表达式
RE字符  意义与范例
+       重复1个或1个以上的前一个RE字符
        egrep 'go+d' file 搜寻范围是 god good goood gooood......等
?0个或1个的前一个RE字符
        egrep 'go?d' file 搜寻范围 god good
|       用或(or)的方式找出字符串
        egrep 'g(la|oo)d file 搜寻范围 glad good
()+     多个重复群组的判别
        echo "AxyzxyzxyzxyzC" |egrep 'A(xyz)C' 意思是A开头，C结尾，中间有一个以上的"xyz"字符串的意思 
注意：  !在正规表达式中不是特殊字符，如果要查包含!与<的字行时， grep '[!>]' file
        [!a-z] 这样反响选择是错误的，[^a-z] 这样才是正确的。
格式化打印：printf 
 
三、sed的用法
sed是一种非交互式的流编辑器，可动态编辑文件。sed处理的对象是文件的数据流。sed的工作模式是对比每一数据行，若符合样式，就执行特定的操作。
sed的语法：sed'样式命令'文件
意思是如果文件某一行符合'样式'，就执行指定是的sed命令，如删除(d)或取代(s)或显示(p)。
这里的'样式'使用一对//含括，表示寻找之意。/1,6/第一行到第6行，/a/,/b/含有a到b的行
注意：sed并不会更改原文件内容。sed的工作方式是读取文件内容，经流编辑后，把结果显示到标准输出，如想要存储sed处理结果，要自行运用转向输出讲结果存成其它文件。
sed的选项：
sed -n 使用安静模式，在一般sed模式中，所有来自STDIN的数据一般都会被列出到屏幕上，加上-n后只有经过sed处理的那才一行才会被列出来。
    -e 直接在指令模式上进行sed的动作编辑
    -f 直接将sed动作写在一个档案内，-f filename 则可以执行filename内的sed动作。
    -r sed的动作支持延申动作表示法
    -i 直接修改档案读取的内容.(直接修改原文本内容，小心操作)
动作说明： [n1[,n2]]function 
n1,n2不见得会存在，一般代表 选择进行的动作的行数，举例来说，如果我的动作是需要在10到20行之间进行的，则10,20[动作行为] 
function 有底下这些东西：
    a:新增， a的后面可以接字符串，而这些字符串会在新的一行出现(目前的下一行)
    i ：插入， i后面可以接字符串，而这些字符串会在新的一行出现(目前的上一行)；
    c ：取代， c的后面可以接字符串，这些字符串可以取代 n1,n2 之间的行！
    d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
    p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运作～
    s ：取代，可以直接直接进行取代的工作！通常这个 s 的动作可以搭配 正则表示法！例如 1,20s/old/new/g 就是！
sed的语法：
sed 's/要取代的字符/新字符/g'                g表示全局的意思
1、删除某一段范围的数据行
  sed '1,4d' file 把第1到第4行数据删除，剩下的显示出来。($代表最后一行'1,$')
2、把含有样式的数据行删除
  sed '/ab/d' file 把含有ab的所有行删除。 sed '/[0-9]\{3\}/d' file 把含有3为数的行删除。\{3\}表示//要寻找的3个数字的字符串 sed '/^$/d' file 删除空白行
3、把不含样式的行删除
  sed '/ab/!d' 不含ab的行删除，剩下的显示出来。(或者说把涵ab的行不删除
4、把含有样式的数据行显示出来(但sed默认也显示不符合的数据行)
 sed '/ab/p' 把含有ab的行显示出来，不符合的也显示出来   -n会抑制默认显示其它行 sed -n '/ab/p' 只把含ab的行显示出来。
5、取代
 sed -n 's/ab/AB/p' file 把file中每一行第一个出现ab的字符串换位AB，sed -n 's/ab/AB/gp' file 把file中每行所有的ab都换为AB
 sed -n 's/ab//p' file 把file中每行第一个ab删除(把ab置换成空字符串就是删除)
 sed 's/^...//' file 把每一行开头的3个字符删除，如果^是$，则把每行最后3个字符删除。
6、取用符合样式的字符串
 sed -n 's/\(ab\)/\1cd/p' file 把每行第一个出现ab的字符换为abcd 。可分解为sed -n 's/ \(ab\) / \1cd /p 其中( ) 1之前都用\来转义，依旧是//模式
7、找到符合样式的数据后，再进行取代操作
 sed -n '/AAA/s/ab/AB/p' file 找到含有AAA的行后，把第一个出现的ab换成AB(如果是gp，就把每行出现的ab换成AB)
 sed -n '/aaa/,/bbb/s/123/456/gp'  file将含有aaa到bbb的那几行，把所有的123换成456
 sed -n '2,4s/a/b/p' file  由第2行到第4行，把出现的第1个a换成b
例子：
cat /etc/passwd| sed '2a hello world'
在第2行的后边加一行内容是helloworld，如果a前没有数字.就在每行后边另起一行，内容为hello world (如果前边的话用i)
cat /etc/passwd| sed '2i one \ two ' 
在第2行前边增加2行，内容分别为one、two ，每行之间要用 \(回车) 隔开
cat /etc/passwd | sed '2i 1 \
2 \
3 \
4 \
5'
在第2行前边增加5行，内容分别是1 2 3 4 5
cat /etc/passwd | sed  '1c hello world'  把第1行内容换为hello world
cat /etc/passwd | sed  '2,4c hello world'  把第2-4行内容换为hello world
cat /etc/passwd | sed -n '1p'  显示第1行 如果是 sed -n '2,3p' 为显示第2行和第3行。 sed '$p'显示最后一行 
grep -v '^$' file | grep -v '^#' 和 egrep -v '^$|^#' regular_express.txt  $代表最后一行去除空白行与行首为 # 的行列 
cat /etc/passwd |sed -e '1d' -e '2,3c hello world'  把第1行删除，把第2行和第3行内容换成hello world
注意:
如果sed后跟多个选项，务必使用-e参数
 
四、awk的用法
awk是一种可以处理数据、产生格式化报表的语言。它的工作方式是读取数据，将每一行数据视为一条记录，每笔记录以字段分隔符分成若干字段，然后输出各个字段的值。
awk对每一条记录，都会套用一个"样式{操作}"，如果该行符合样式，就执行指定的操作。
样式或操作之一可以省略。如果只有样式，表示要显示符合样式的行；如果只有操作，表示对每一行数据都执行该项操作。
awk的常用的作用格式：
awk "样式"   文件：把符合样式的数据行显示出来。
awk ‘{操作}’ 文件：对每一行都执行{}中的操作。
awk ‘样式{操作}’对符合样式的数据行，执行{}中的操作。
awk的几种用法：
1、awk '/root/' file 
   显示file中root的行
2、awk '{print $1,$2}' file         ","可以省略如果让两个字符以空格隔开的话用 awk '{print $1 "\t" $2'
   显示file中每一行的第1个和第2个字段(默认以空格为分隔符)
3、awk '/ab/{print $1,$2}' file
   显示file中有ab的行的第1个和第2个字段(以空格为分隔符)
4、awk -F: '/^root/{print $2,$3}' file
   以":"为分隔符，把以root开头的行中的第2个和第3个字符显示出来。
5、awk -F: 'BEGIN{OFS="++++"}/^root/{print $1,$2,$3}' /etc/passwd 
   把passwd中，以":"为分隔符找出首行为root的行，并显示前3个字段，并且字段之间以+++隔开
实例：
变量名称代表意义
NF每一行$0拥有的字段总数(默认以空格或Tab为分隔符)
NR目前awk所处理的是第几行数据
FS目前的分隔符，默认是空格键
[root@centos ~]# cat 1
a2a3a4a5a
b2b3b4b5b
c2c3c4c5c
[root@centos ~]# cat 1|awk '{print $1 "\t 行:" NR "\t 该行总字段:" NF}'
a 行:1 该行总字段:5
b 行:2 该行总字段:5
c 行:3 该行总字段:5
查阅passwd第三栏数据小于10的数据的行，并且仅列出账号和第三栏。
cat /etc/passwd|awk '{FS=":"}$3<10 {print $1 "\t" $3}'  
root:x:0:0:root:/root:/bin/bash
bin1
daemon2
...
mail8
上边第一行会全部显示出来，这是因为我们读入第一行的时候，那些变数 $1, $2..默认还是以空格键为分隔的，所以虽然我们定义了 FS=":" 了， 但是却仅能在第二行后才开始生效。
那么怎么办呢？我们可以预先设定 awk 的变量啊！ 利用 BEGIN 这个关键词！这样做：cat /etc/passwd|awk 'BEGIN{FS=":"}$3<10 {print $1 "\t" $3}'
显示ip地址
ifconfig |grep 'inet addr'|grep Bcast|awk '{print $2}'|awk -F: '{print $2}' 
显示网络名称
cat /proc/net/dev |awk -F: '/eth.:|sit.:|wlan.:|ppp.:/{print $1}'
 
