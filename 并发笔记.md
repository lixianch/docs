## 并发 ##
### 线程基础 ###
**1.定义任务** 
线程可以驱动任务，因此需要一种描述任务的方式，可以通过实现Runnable接口来提供。要想定义任务只需实现Runnable接口，编写run方法，这个方法并无特殊之处——它不会产生任何内在的线程能力。要想实现线程行为，必须显示地将其附着到线程之上。
```java
public class LiftOff implements Runnable {
    private static Integer taskId=0;
    protected Integer countDown = 10;
    private final Integer id = taskId++;
    public LiftOff(){}
    public LiftOff(Integer countDown){
        this.countDown = countDown;
    }
    public String status(){
        return "#"+id+"("+(countDown > 0? countDown : "LiftOff")+")";
    }
    @Override
    public void run() {
        while(countDown-- > 0){
            System.out.println(status());
            Thread.yield();
        }
    }
}
```
**2.Thread类**   
将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器，然后调用Thread的run方法，启动线程。
```java
public class BasicThreads {
    public static void main(String[] args){
        Thread t = new Thread(new LiftOff());
        t.start();
        System.out.println("waiting for LiftOff");
    }
}
```
**3.使用Executor**  
Java SE5的java.util.concurrent包中的执行器(Executor)可以管理Thread对象。Executor可以管理异步任务的执行，而无须显示地管理线程的生命周期。Executor在Java SE5后是启动任务的优选方法。  
***执行器使用完毕后一定要调用shutdown()方法手动关闭。***  
创建执行器方法：
```java
ExecutorService exec = Executors.newCachedThreadPool();
```  
执行器种类：  

执行器名称|描述 
---|---
CachedThreadPool|CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理的Executor的首选。   
FixedThreadPool|FixedThreadPool可以一次性预先执行代价高昂的线程分配，因此也就可以限制线程的数量。这可以节省时间，因为不用为每个任务都固定地付出创建线程的开销。在事件驱动的系统中，需要线程的事件处理器，通过直接从池中获取线程，也可以尽快得到服务。不会滥用可获得的资源，因为FixedThreadPool使用的Thread对象的数量是有界的。  
SingleThreadExecutor|SingleThreadExecutor是线程数量为1的FixedThreadPool。SingleThreadExector会序列化所有提交给它的任务，并会维护它自己(隐藏)的悬挂任务队列。  
  
**4.从任务中产生返回值**  
从任务中产生返回值可以通过实现Callable接口实现，在Java SE5中引入的Callable是一种具有类型参数的泛型，它的类型参数表示的是从call()中返回的值，并且必须使用ExecutorService.submit()方法调用它。
```java
public class CallableDemo {


    public static void main(String[] args){
        ExecutorService exec = Executors.newCachedThreadPool();
        List<Future<String>> results = new ArrayList<Future<String>>();
        for(int i = 0; i < 5; i++){
            results.add(exec.submit(new TaskWithResult(i)));
        }

        try {
            for(Future<String> r : results){
                System.out.println(r.get());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        } finally {
            exec.shutdown();
        }
    }
}

class TaskWithResult implements Callable<String>{
    private Integer id;
    public TaskWithResult(Integer id){
        this.id = id;
    }
    @Override
    public String call() throws Exception {
        return "TaskWithResult-"+id+" result";
    }
}
```   

**5.休眠**  
两种方式：
1. 调用线程sleep()方法
2. 使用TimeUnit 
`TimeUnit.MICROSECONDS.sleep(100);`
**注意：休眠时需要捕获InterruptedException异常** 
 
**6.优先级**
尽管CPU处理现有线程集的顺序是不确定的，但是调度器将倾向于让优先权最高的线程先执行。然而，这并不是意味着优先权较低的线程将得不到执行(也就是说，优先权不会导致死锁)。优先级较低的线程仅仅是执行的频率较低。
```java
public class SimplePriorities implements Runnable{
    private int countDown=5;
    private volatile double d;
    private int priority;
    public SimplePriorities(Integer priority){
        this.priority = priority;
    }

    @Override
    public String toString() {
        return Thread.currentThread()+":"+countDown;
    }

    @Override
    public void run() {
        Thread.currentThread().setPriority(priority);
        while(true) {
            for (int i = 0; i < 10000; i++) {
                d += (Math.PI+Math.E)/i;
            }
            System.out.println(this);
            if(countDown-- <= 0)return;
        }
    }

    public static void main(String[] args){
        ExecutorService exec = Executors.newCachedThreadPool();
        for(int i = 0; i < 5; i++){
            exec.execute(new SimplePriorities(Thread.MIN_PRIORITY));
        }

        exec.execute(new SimplePriorities(Thread.MAX_PRIORITY));
        exec.shutdown();
    }
}
```
**7.让步**
如果知道已经完成了在run()方法的循环的一次迭代过程中所需的工作，就可以给线程调度机制一个暗示：你的工作已经做完了，可以让别的线程使用CPU了。这个暗示将通过调用yield()方法来作出(不过这只是一个暗示，没有任何机制保证它将会被采纳)。当调用yield()时，也只是建议具有相同优先级的其他线程可以运行。
**8.后台线程**
所谓后台(daemon)线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说，只要有任何非后台线程还在运行，程序就不会终止。
```java
public class SimpleDaemons implements Runnable{

    @Override
    public void run() {
        try {
            while (true){
                System.out.println(Thread.currentThread() + ":" + this);
                TimeUnit.MICROSECONDS.sleep(100);
            }
        } catch (InterruptedException e) {
            System.out.println("Interrupted");
        }
    }

    public static void main(String[] args){
        Thread daemon = null;
        try {
            for(int i = 0; i < 5; i++){
                daemon = new Thread(new SimpleDaemons());
                daemon.setDaemon(true);
                daemon.start();
                TimeUnit.MICROSECONDS.sleep(1000);
            }
        } catch (InterruptedException e) {
            System.out.println("Main thread interrupted");
        }
    }
}
```
***注意：必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程。***
后台线程可以通过ThreadFactory来创建，每个静态的ExecutorService创建方法都被重载为一个接受一个ThreadFactory对象，而这个对象将被用来创建新的线程，如下：
```java
public class DaemonThreadFactory implements ThreadFactory {
    @Override
    public Thread newThread(Runnable r) {
        Thread t = new Thread(r);
        t.setDaemon(true);
        return t;
    }
}

public class DaemonFromFactory implements Runnable{
    @Override
    public void run() {
        try {
            while(true){
                TimeUnit.MICROSECONDS.sleep(100);
                System.out.println(Thread.currentThread() + ": " + this);
            }
        } catch (InterruptedException e) {
            System.out.println("Interrupted");
        }
    }

    public static void main(String[] args) {
        try {
            ExecutorService exec = Executors.newCachedThreadPool(new DaemonThreadFactory());
            for(int i = 0; i < 10; i++){
                exec.execute(new DaemonFromFactory());
            }

            System.out.println("All daemons started");
            TimeUnit.MICROSECONDS.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```
可以通过调用isDaemon()方法来确定线程是否是一个后台线程。如果是一个后台线程，那么它创建的任何线程将被自动设置成后台线程，如下：
```java
/**
 * 后台线程创建的子线程默认也是后台线程，即子线程的daemon属性继承父线程的daemon属性值
 */
class Daemon implements Runnable {

    @Override
    public void run() {
        Thread[] threads = new Thread[5];
        for(int i = 0; i < 5; i++){
            threads[i]=new Thread(new DaemonSpawn());
            threads[i].start();
            System.out.println("DaemonSpawn[" + i + "] started");
        }

        for(int i = 0; i < 5; i++){
            System.out.println("DaemonSpawn["+ i +"] isDaemon: " + threads[i].isDaemon());
        }
    }
}
class DaemonSpawn implements Runnable {

    @Override
    public void run() {
        while (true){
            Thread.yield();
        }
    }
}
public class Daemons {
    public static void main(String[] args) {
        Thread t = new Thread(new Daemon());
        t.setDaemon(true);
        t.start();
        try {
            TimeUnit.MICROSECONDS.sleep(1000);
        } catch (InterruptedException e) {
            System.out.println("Main thread interrupted");
        }
    }
}
```
后台线程在不执行finally子句的情况下就会终止其run()方法：
```java
class ADaemon implements Runnable {

    @Override
    public void run() {
        try {
            System.out.println("Starting ADaemon");
            TimeUnit.MILLISECONDS.sleep(100);
        } catch (InterruptedException e) {
            System.out.println("Exiting via interruptedException");
        } finally {
            System.out.println("daemon thread finally execute");
        }

    }
}
public class DaemonsDontRunFinally {
    public static void main(String[] args){
        Thread t = new Thread(new ADaemon());
        t.setDaemon(true);
        t.start();
    }
}
```
**9.编码的变体**
任务类可以通过实现Runnable接口实现。然而，在非常简单的情况下，也可以使用直接从Thread继承这种可替换的方式，如下：
```java
public class SimpleThread extends Thread {
    private int countDown = 5;
    private static int threadCount = 0;
    public SimpleThread(){
        super(Integer.toString(++threadCount));
        start();
    }
    @Override
    public String toString() {
        return "#" + getName() + "(" + countDown + ")";
    }

    @Override
    public void run() {
        while (true){
            System.out.println(this);
            if(--countDown == 0) return;
        }
    }

    public static void main(String[] args){
        for(int i = 0; i < 5; i++)
            new SimpleThread();
    }
}
```
自管理的Runnable，如下：
```java
public class SelfManaged implements Runnable {
    private int countDown = 5;
    @Override
    public void run() {
        while (true){
            System.out.println(this);
            if(--countDown == 0)
                return;
        }
    }

    public SelfManaged(){
        Thread t = new Thread(this);
        t.start();
    }

    public static void main(String[] args){
        for(int i = 0; i < 5; i++){
            new SelfManaged();
        }
    }
}
```
***注意：start()如果在构造器中调用，在简单情况下，可能是安全的，但是应该意识到，在构造器中启动线程可能会变得很有问题，因为另一个任务可能会在构造器结束之前开始执行，这意味着该任务能够访问处于不稳定状态的对象。这是优选Executor而不是显式地创建Thread对象的另一个原因。***
**10.加入一个线程join**
一个线程可以在其他线程之上调用join()方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程t上调用t.join()，此线程将被挂起，直到目标线程t结束才恢复(即t.isAlive()返回为假)。
 也可以在调用join()时带上一个超时参数(单位可以是毫秒，或者毫秒和纳秒)，这样如果目标线程在这段时间到期时还没有结束的话，join()方法总能返回。
对join()方法的调用可以被中断，做法是在调用线程上调用interrupt()方法，这时需要用到try-catch子句。
```java

```